<entry>
<time>16:12</time>
<subj>Работа не волк!</subj>
<text>Блин, кто придумал работать в эти дни?! Было же раньше &#151; 10 дней выходных, и счастье. А сейчас &#151; в офисе только треть народа, да и те ни хрена не делают. В такой обстановке совершенно не работается. Свалю-ка я отседова. Я и так за сегодня много сделал &#151; отловил скверный баг (вечером расскажу).</text>
<keywords>разное</keywords>
<stamp>1052208735</stamp>
<entry>
<time>01:26</time>
<subj>История одной ошибки</subj>
<text>Хочу поделиться радостью&nbsp;&#151; сегодня я&nbsp;за полчаса отловил ошибку, над которой неделю назад бился несколько часов.<br><b>Дано</b>: Многопоточная конвеерная программа, которая поэтапно производит манипуляции с&nbsp;поступающими текстовыми сообщениями. Один из этапов&nbsp;&#151; подстановка вместо метатегов определённых переменных (т.е. парсинг шаблона). После <nobr>какого-то</nobr> несущественного изменения (которое, как потом оказалось, ни в&nbsp;чём не было виновато) в&nbsp;объекте парсере при определённом входном сообщении программа вдруг падает (segmentation fault). Ошибка повторяется всегда при данном входном сообщении. Правда анализ <nobr>core-файла</nobr> показывает, что падение происходит в&nbsp;разных точках.<br><b>Вопрос</b>: В&nbsp;чём дело?<cut><br><b>Неправильный подход</b>: В&nbsp;отладочном выводе программы сразу обратила на себя строчка:<br><code>in&nbsp;free():&nbsp;warning:&nbsp;chunk&nbsp;is&nbsp;already&nbsp;free</code><br>Для тех, кто не в&nbsp;курсе&nbsp;&#151; такое выдаёт сама библиотечная команда free, когда ей скармливаешь указатель на место, которое не выделялось ранее (new, malloc и&nbsp;т.д.). В&nbsp;большинстве случаев это означает, что мы где то повторно освобождаем уже освобождённую память и&nbsp;не является смертельным. Я&nbsp;не люблю оставлять подобные грехи в&nbsp;программе и&nbsp;поэтому решил, что как только найду искомую ошибку (см. &laquo;Дано&raquo;), тут&nbsp;же уберу эту лажу.<br>Так как падение программы было легко воспроизводимо&nbsp;&#151; я&nbsp;решил сделать пошаговый проход, чтобы найти точное место&nbsp;&#151; где она падает. Вроде&nbsp;бы всё просто, но не тут то было. Это место ускользало от меня&nbsp;&#151; когда я&nbsp;делал пошаговый проход по тому участку, где программа падала в&nbsp;прошлый раз&nbsp;&#151; всё работало замечательно, а&nbsp;пройдя этот участок делал Run и&nbsp;ошибка выползала в&nbsp;другом месте. В&nbsp;общем программа вела себя непредсказуемо, но путём несколькочасовых мук и&nbsp;разочарований я&nbsp;<nobr>нашёл-таки</nobr> три точки в&nbsp;коде, на которых выползал &laquo;Segmentation fault&raquo; (они совпали с&nbsp;теми, что показывал анализ <nobr>core-файлов</nobr> :) ), и&nbsp;ни к&nbsp;чему не пришёл&hellip; Вернее я&nbsp;нашёл непосредственную причину ошибок&nbsp;&#151; странные значения некоторых указателей&nbsp;&#151; но откуда эти значения берутся выяснить не представлялось никакой возможности. В&nbsp;общем, потратив много часов, я&nbsp;обессилевший и&nbsp;расстроенный, как бывает, когда чувствуешь, что бьёшься лбом об стенку, ушёл ни с&nbsp;чем.<br><b>Правильный подход</b>: Сегодня (уже вчера) на свежую голову решил сначала разобраться с&nbsp;тем ворнингом от функции free(). Найти место было несложно, поскольку у&nbsp;меня достаточно подробный отладочный вывод:<br><code>&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(kvt_node->value)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free&nbsp;(kvt_node->value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kvt_node->value&nbsp;=&nbsp;NULL;<br>&nbsp;&nbsp;&nbsp;}</code><br>При пошаговом прогоне я&nbsp;обнаружил, что <code>kvt_node->value</code> впервые используется и&nbsp;выдаёт предупреждение именно в&nbsp;этом месте (за исключением конструктора структуры key_value_t (тип указателя kvt_node):<br>Вызов:<br><code>&nbsp;&nbsp;&nbsp;<b>new</b>&nbsp;key_value_t&nbsp;(key)</code><br>Определение:<br><code>&nbsp;&nbsp;&nbsp;<b>explicit</b>&nbsp;key_value_t&nbsp;(const&nbsp;char*&nbsp;k,&nbsp;const&nbsp;char*&nbsp;v&nbsp;=&nbsp;NULL):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;(NULL),&nbsp;right&nbsp;(NULL)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;/*&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(v&nbsp;!=&nbsp;NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;((value&nbsp;=&nbsp;strdup&nbsp;(v))&nbsp;==&nbsp;NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free&nbsp;(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;666;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}</code><br>И тут замечаем&nbsp;&#151; если <code>v&nbsp;==&nbsp;NULL</code>, то value остаётся тем, чем случайно сделала его система&nbsp;&#151; хрен знает чем. А&nbsp;теперь представим, что это &laquo;хрен знает что&raquo; случайно совпало с&nbsp;местом, где <nobr>что-то</nobr> реально намеренно уже выделено&nbsp;&#151; что произойдёт во время <code>free&nbsp;(kvt_node->value)</code>? <nobr>То-то</nobr> же!!!<br>Добавил к&nbsp;инициализаторам <code>value&nbsp;(NULL)</code>&nbsp;&#151; и&nbsp;всё, программа работает стабильно и&nbsp;правильно.<br><b>Выводы</b>: Данная ошибка была допущена <nobr>из-за</nobr> случайной невнимательности&nbsp;&#151; человеческий фактор, от которого никто не застрахован. Но всё же эта история меня <nobr>кое-чему</nobr> научила: <i>не следует игнорировать очевидные симптомы ошибки, лежащие на поверхности</i>, надо сначала исправить их, а&nbsp;потом копать вглубь. Кстати, этот принцип упомянут в&nbsp;книге &laquo;Наука отладки&raquo;, которую я&nbsp;<nobr>всё-ещё</nobr> почитываю.<br>Ну и&nbsp;ещё один фундаментальный принцип&nbsp;&#151; <i>всегда производить начальную инициализацию переменных</i>.</text>
<keywords>программирование, отладка, c&c++</keywords>
<stamp>1052242017</stamp>

<posts>3</posts>
